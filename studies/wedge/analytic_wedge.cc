/**
 * @file analytic_wedge.cc
 *
 * Compares the analytic results of the ASA wedge to the results
 * generated by WaveQ3D under similar conditions.
 *
 */
#include <usml/waveq3d/waveq3d.h>
#include <fstream>
#include <iostream>
#include <list>
#include <string>
#include <stdio.h>
#include <stdlib.h>

using namespace usml::waveq3d ;
using namespace usml::ocean ;

/**
 * The following test is to compare the results produced by
 * WaveQ3D to results obtained from the Analytic Wedge problem
 * produced by Deane and Tindle.
 */
int main() {
    cout << "=== analytic_wedge ===" << endl ;

    // define scenario parameters
    int num_targets = 1 ;
    wposition::compute_earth_radius( 0.0 ) ;
    wposition1 wedge_apex(0.0, 0.0, 0.0);
    wposition1 pos(0.0, 0.0, 0.0);
    pos.altitude(-100.0);

    // setup fan parameters
    seq_linear de( -87.0, 1.0, 87.0 ) ;
    seq_linear az( -90, 5.0, 90.0 ) ;
    seq_log freq( 25.0, 25.0, 1 ) ;
    const double time_max = 2.7 ;
    const double time_step = 0.01 ;

    // setup files to output all data to

    const char* csvname = "wedge/analytic_wedge_eigenray.csv";
    const char* ncname = "wedge/analytic_wedge_proploss.nc";
    const char* ncname_wave = "wedge/analytic_wedge_eigenray_wave.nc";

    // build sound velocity profile

    const double c0 = 1500.0 ;
    profile_model*  profile = new profile_linear(c0) ;
    profile->flat_earth(true);
    boundary_model* surface = new boundary_flat() ;

//    boundary_model* bottom  = new boundary_slope(
//        wedge_apex, 200.0, to_radians(2.86) ) ;
    boundary_model* bottom = new boundary_flat(200.0);

    ocean_model ocean( surface, bottom, profile ) ;

    // initialize proploss targets and wavefront

    wposition target( num_targets, 1, pos.latitude()+0.025, pos.longitude(), -30.0 ) ;
//    double inc = ( wedge_apex.latitude() - pos.latitude() ) / num_targets ;
//    for( int n=1; n < target.size1(); ++n ) {
//        target.latitude( n, 0, pos.latitude() + inc * n );
//    }
    proploss loss( &target ) ;
    wave_queue wave( ocean, freq, pos, de, az, time_step, &loss ) ;
//    wave_queue wave( ocean, freq, pos, de, az, time_step ) ;

    // propagate wavefront
    cout << "writing wavefronts to " << ncname_wave << endl;

    wave.init_netcdf( ncname_wave );
    wave.save_netcdf();

    while ( wave.time() < time_max ) {
        wave.step() ;
        wave.save_netcdf();
    }

    wave.close_netcdf();

    //compute coherent propagation loss and write eigenrays to disk

    loss.sum_eigenrays();
    cout << "writing proploss to " << ncname << endl;
    loss.write_netcdf(ncname,"ASA Anaylytic Wedge");

    //save results to spreadsheet and compare to analytic results

    cout << "writing tables to " << csvname << endl;
    std::ofstream os(csvname);
    os << "time,intensity,phase,s_de,s_az,t_de,t_az,srf,btm,cst" << endl;
    os << std::setprecision(18);
    cout << std::setprecision(18);

    std::list < struct eigenray > *list_of_eigenrays = loss.eigenrays(0,0);           //list of eigenrays for a given source/receiver
    std::list < struct eigenray > ordered_list;

    for(std::list< struct eigenray >::iterator num=list_of_eigenrays->begin(); num!=list_of_eigenrays->end(); ++num) {
        eigenray ray = *num;
        if(ray.bottom == ray.surface) {
            ordered_list.push_back(ray);
        }
        else if(ray.bottom > ray.surface) {
            ordered_list.insert(ordered_list.end()--,ray);
        }
        else {
            ordered_list.push_back(ray);
        }
    }

    for(std::list< struct eigenray >::iterator it=ordered_list.begin();
            it!=ordered_list.end(); ++it)
    {
        eigenray ray = *it;
        os << ray.time
           << "," << ray.intensity(0)
           << "," << ray.phase(0)
           << "," << ray.source_de
           << "," << ray.source_az
           << "," << ray.target_de
           << "," << ray.target_az
           << "," << ray.surface
           << "," << ray.bottom
           << "," << ray.caustic
           << endl;
    }
}
