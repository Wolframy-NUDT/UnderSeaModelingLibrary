/**
 * @file analytic_wedge.cc
 *
 * Compares the analytic results of the ASA wedge to the results
 * generated by WaveQ3D under similar conditions.
 *
 */
#include <usml/waveq3d/waveq3d.h>
#include <fstream>
#include <iostream>
#include <list>
#include <string>
#include <stdio.h>
#include <stdlib.h>

using namespace usml::waveq3d ;
using namespace usml::ocean ;

/**
 * The following test is to compare the results produced by
 * WaveQ3D to results obtained from the Analytic Wedge problem
 * produced by Deane and Tindle.
 */
int main() {
    cout << "=== analytic_wedge ===" << endl ;

    // define scenario parameters
    int num_targets = 100 ;
    double m_2_deg = 1.0 / ( 1852.0 * 60.0 ) ;            // conversion factor from meters to degree lat
    const double wedge_length = 4000.0 ;
    const double wedge_depth = 200.0 ;
    const double wedge_angle = atan( wedge_depth / wedge_length ) ;
    const double dist = wedge_length * m_2_deg ;
    wposition::compute_earth_radius( 0.0 ) ;
    wposition1 wedge_apex ;
    wedge_apex.latitude(dist) ;
    wposition1 pos ;
    pos.altitude(-100.0) ;

    // setup fan parameters
    seq_linear de( -90.0, 1.0, 90.0 ) ;
    seq_linear az( -90.0, 5.0, 90.0 ) ;
    seq_log freq( 25.0, 25.0, 1 ) ;
    const double time_max = 3.0 ;
    const double time_step = 0.01 ;

    // setup files to output all data to

    const char* csvname = USML_STUDIES_DIR "/analytic_wedge/analytic_wedge_eigenray.csv";
    const char* ncname = USML_STUDIES_DIR "/analytic_wedge/analytic_wedge_proploss.nc";
    const char* ncname_wave = USML_STUDIES_DIR "/analytic_wedge/analytic_wedge_eigenray_wave.nc";

    // build sound velocity profile

    profile_model*  profile = new profile_linear() ;
//    profile->flat_earth(true);
    boundary_model* surface = new boundary_flat() ;

//    boundary_model* bottom  = new boundary_slope(
//        wedge_apex, 0.0, wedge_angle ) ;
    const double c0 = 1500.0 ;
    reflect_loss_model* asa_wedge =
        new reflect_loss_rayleigh( 1.5, 1700.0/c0, 0.5 ) ;        // Create rayleigh model similar to the ASA wedge geophysical params
    boundary_model* bottom  = new boundary_slope(
        wedge_apex, 0.0, wedge_angle, 0.0, asa_wedge ) ;

    ocean_model ocean( surface, bottom, profile ) ;

    // initialize proploss targets and wavefront

    wposition target( num_targets, 1, pos.latitude(), pos.longitude(), -30.0 ) ;
    double inc = ( 3500.0 * m_2_deg ) / num_targets ;
    for( int n=1; n < target.size1(); ++n ) {
        target.latitude( n, 0, inc * n );
//        cout << "target(" << n << ",0) dist src_lat apex: " << target.latitude(n,0) / m_2_deg << endl;
//        double dist = target.latitude(n,0) / m_2_deg ;
//        target.altitude( n, 0, -100 + (dist * tan(wedge_angle / 2.0)) ) ;
//        cout << "target.alt(" << n << ",0): " << target.altitude(n,0) << endl;
    }
    proploss loss( &target ) ;
    wave_queue wave( ocean, freq, pos, de, az, time_step, &loss ) ;

    // propagate wavefront
    cout << "writing wavefronts to " << ncname_wave << endl;

    wave.init_netcdf( ncname_wave );
    wave.save_netcdf();

    while ( wave.time() < time_max ) {
        wave.step() ;
        wave.save_netcdf();
    }

    wave.close_netcdf();

    //compute coherent propagation loss and write eigenrays to disk

    loss.sum_eigenrays();
    cout << "writing proploss to " << ncname << endl;
    loss.write_netcdf(ncname,"ASA Anaylytic Wedge");

    //save results to spreadsheet and compare to analytic results

    cout << "writing tables to " << csvname << endl;
    std::ofstream os(csvname);
    os << "target,depth,range,intensity" << endl;
    os << std::setprecision(18);
    cout << std::setprecision(18);

    for(int n = 0; n < target.size1() ; ++n)
    {
        os << n << ","
           << target.altitude(n,0) << ","
           << target.latitude(n,0) / m_2_deg << ","
           << -loss.total(n,0)->intensity(0)
           << endl;
    }
}
