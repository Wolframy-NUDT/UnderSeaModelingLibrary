/**
 * @file envelope_generator.h
 */
#pragma once

#include <iostream>
#include <fstream>

#include <boost/shared_ptr.hpp>
#include <usml/types/wposition1.h>
#include <usml/types/seq_vector.h>
#include <usml/ocean/ocean_shared.h>
#include <usml/threads/thread_task.h>
#include <usml/threads/read_write_lock.h>
#include <usml/eigenverb/envelope_collection.h>

namespace usml {
namespace eigenverb {

using namespace usml::types;
using namespace usml::ocean;
using namespace usml::threads;

/// @ingroup eigenverb
/// @{

/**
 * Combines eigenverbs to create the reverberation envelope,
 * as a function of travel time, frequency, and receiver beam number,
 * for a fixed set of azimuthal directions around each receiver.
 * An overlap is computed between each receiver eigenverb and
 * all of the source eigenverbs in its vicinity.  This overlap creates
 * a Gaussian reverberation envelope contribution in the time domain.
 *
 * The reverberation envelope contributions for each receiver azimuth
 * are incoherently power summed.  Beam patterns are applied to the
 * eigenverbs during envelope generation.  This allows a single pair of
 * eigenverbs to create separate envelopes for each receiver beam.
 * Eigenverbs and envelopes are computed as functions of frequency
 * so that the pre-computed reverberation results can be applied
 * to a variety of transmitted waveforms in the sonar training system.
 *
 * Invoked as a background thread_task by the sensor_pair for
 * a specific source/receiver combination, whenever one of the sensors
 * updates its eigenverbs. If an existing envelope_generator is running for
 * this sensor_pair, that task is aborted before the new envelope_generator
 * is created.
 */
class USML_DECLSPEC envelope_generator: public thread_task {
public:

	/**
	 * Default pulse length of the signal (sec)
	 */
	static double pulse_length;

	/**
	 * Default duration of the reverberation envelope (sec).
	 */
	static double time_maximum;

	/**
	 * Default sampling period for the reverberation envelope (sec).
	 */
	static double time_step;

	/**
	 * Copies envelope computation parameters from static memory into
	 * this specific task.
	 *
	 * @param num_azimuths	Number of azimuths to create in the output.
	 */
	envelope_generator( size_t num_azimuths );

	/**
	 * Virtual destructor
	 */
	virtual ~envelope_generator() {
	}

	/**
	 * Overloads of the thread_task run method.
	 * Executes the WaveQ3D propagation model.
	 */
	virtual void run() {}

	/**
	 * Set to true when this task complete.
	 */
	bool done() {
		return _done;
	}

protected:

	/**
	 * Computes the broadband scattering strength for a specific interface.
	 *
	 * @param interface		Interface number of ocean component that is doing
	 * 						the scattering. See the eigenverb class header
	 * 						for documentation on interpreting this number.
	 * @param location      Location at which to compute attenuation.
	 * @param frequencies   Frequencies over which to compute loss. (Hz)
	 * @param de_incident   Depression incident angle (radians).
	 * @param de_scattered  Depression scattered angle (radians).
	 * @param az_incident   Azimuthal incident angle (radians).
	 * @param az_scattered  Azimuthal scattered angle (radians).
	 * @param amplitude     Change in ray strength in dB (output).
	 */
	void scattering( size_t interface, const wposition1& location,
			const seq_vector& frequencies, double de_incident,
			double de_scattered, double az_incident, double az_scattered,
			vector<double>* amplitude);

private:

	/** Set to true when WaveQ3D propagation model task complete. */
	bool _done;

	/** Ocean data to use for the envelope calculation. */
	shared_ptr<ocean_model> _ocean;

	/**
	 * Pulse length for this specific computation (sec).
	 */
	const double _pulse_length;

	/**
	 * Duration of the reverberation envelope (sec).
	 */
	const double _time_maximum;

	/**
	 * Sampling period for the reverberation envelope (sec).
	 */
	const double _time_step;

	/**
	 * Collection of envelopes generated by this calculation.
	 */
//	envelope_collection _envelopes ;
} ;

/// @}
}	// end of namespace eigenverb
}   // end of namespace usml
